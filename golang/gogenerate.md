## go generate

* ソースコード自動生成ツール
* 決められたフォーマットのコメント`//go:generate CMD ARG`を生成元ソースに書く
    * 予め用意されている変数が複数あって、このコメントで使える（`$GOFILE`(=このソースファイaルの名前)とか)
* ソースを保存後にそのDIR内で`go generate`を叩く
* __コメントに書いた`CMD`を__ , __該当ソースに適用して生成された別ソースを__ , 同じDIRに出力する 

* そもそも自動生成出来て何が嬉しいのか？
    * __一部だけ異なる類似ソースを大量に書く必要があり、かつ将来的にこのソースが増加することが分かっている__ という場合
        * そもそもこういうユースケース自体がイケてないよね？という話はあると思いつつ
    * __reflectionぽい機能が実現できる__ (この用途が多く見られる)
        * go generateはあくまで実行時ではなく実行前段階(ビルド時)に行うものではあるけど


### 紹介記事まとめ

#### Generic programming in Go using "go generate"
[One Big Fluke › Generic programming in Go using "go generate"](http://www.onebigfluke.com/2014/12/generic-programming-go-generate.html)

* サンプルコードはこちら -> TODO
* 自前struct配列からinterface配列への変換がうまくいかないぉ 、という話が発端
    * __interfaceは内部でポインタのペアを持つ構成になってる__ からね -> [research!rsc: Go Data Structures: Interfaces](http://research.swtch.com/interfaces)
        * 1つ目は型に関する情報
        * 2つ目は実データに関する情報
* これまでならreflection使って解決すべき問題だったが、reflectionおせーし使いたくない
* __1.4から`go generate`使えるようになってこれで出来そうだぜ！__

* `github.com/bslatkin/joiner` によるgenerics likeなソースコード自動生成
    * `go install github.com/bslatkin/joiner`でインストール
    * 生成元ソース, 対象の型に`@joiner`というコメント（アノテーション風）を付加

    ```go
    package main

    //go:generate joiner $GOFILE

    import "fmt"

    // @joiner
    type Person struct {
      FirstName string
      LastName  string
      HairColor string
    }

    func main() {
      people := []Person{
        Person{"Sideshow", "Bob", "red"},
        Person{"Homer", "Simpson", "n/a"},
        Person{"Lisa", "Simpson", "blonde"},
        Person{"Marge", "Simpson", "blue"},
        Person{"Mr", "Burns", "gray"},
      }
      //fmt.Printf("My favorite Simpsons Characters:%s\n", Join(people).With("\n"))
      fmt.Printf("My favorite Simpsons Characters:%s\n", JoinPerson(people).With("\n"))
    }
    ```

    * 保存後、`go generate`を実行すると`xxx_joiner.go`が生成される

    ```go
    // generated by joiner -- DO NOT EDIT
    package main

    import (
      "fmt"
      "strings"
    )

    func (t Person) String() string {
      return fmt.Sprintf("%#v", t)
    }

    type JoinPerson []Person

    func (j JoinPerson) With(sep string) string {
      all := make([]string, 0, len(j))
      for _, s := range j {
        all = append(all, s.String())
      }
      return strings.Join(all, sep)
    }
    ```

    * `go run *.go`で実行 -> OK

    ```
    $ go run *.go

    main.Person{FirstName:"Homer", LastName:"Simpson", HairColor:"n/a"}
    main.Person{FirstName:"Lisa", LastName:"Simpson", HairColor:"blonde"}
    main.Person{FirstName:"Marge", LastName:"Simpson", HairColor:"blue"}
    main.Person{FirstName:"Mr", LastName:"Burns", HairColor:"gray"}
    ```

#### stringerコマンド
[stringer - GoDoc](https://godoc.org/golang.org/x/tools/cmd/stringer)

* 対象ソースを指定し、`String()`メソッドを実装したソースを別名(hoge_string.go)で生成するコマンド
* インストール `go get golang.org/x/tools/cmd/stringer`
* 使用例, 対象ソースディレクトリ(=package path)に移動して`stringer -type=<TYPE> <FILE>`形式で実行

```go
// pill.go

package main

type Pill int

const (
	Placebo Pill = iota
	Aspirin
	Ibuprofen
	Paracetamol
	Acetaminophen = Paracetamol
)
```
```
$ stringer -type=Pill pill.go
$ vi pill_string.go
```
```go
// generated by stringer -type=Pill pill.go; DO NOT EDIT

package main

import "fmt"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{7, 14, 23, 34}

func (i Pill) String() string {
	if i < 0 || i >= Pill(len(_Pill_index)) {
		return fmt.Sprintf("Pill(%d)", i)
	}
	hi := _Pill_index[i]
	lo := uint8(0)
	if i > 0 {
		lo = _Pill_index[i-1]
	}
	return _Pill_name[lo:hi]
}
```

* 使用例:`go generate`叩く版, ソースコメントにgo generateで実行するコマンドを定義し、保存して終了後に`go generate`を実行する
    * [Generate Go files by processing source](http://golang.org/cmd/go/#hdr-Generate_Go_files_by_processing_source)

```go
// pill.go

package main

//go:generate stringer -type=Pill $GOFILE

type Pill int

const (
	Pracebo Pill = iota
	Aspirin
	Ibuprofen
	Paracetamol
	Acetaminophen = Paracetamol
)
```
```
$ go generate
$ ls
pill.go pill_string.go
```

#### progrium/go-extpoints
[progrium/go-extpoints](https://github.com/progrium/go-extpoints), 良さげ

* 使い方の一例(公式repoより)
    * `extpoints`サブパッケージを掘り、その下に`interfaces.go`を用意する
        * ここに任意のinterface T型 を定義する
        * __`go generate`実行時に、このinterfaceを元にソースが自動生成される(ようにする)__
    * ROOTパッケージ下に`go generate`実行様に特化した`extensions.go`を用意する
        * `//go:generate go-extpoints`コメント(のみ)を記述
    * `go generate`を実行すると、`extpoints/extpoints.go`が生成される
        * `template.go`に定義されているテンプレート・ソースをレンダリングしてgoファイルを生成する
    * ROOTパッケージ下に実行用のmain関数を持つgoファイル(`main.go`的な) を用意する
        * 定義したextpoints.T型の変数を用意
        * この変数やそのメソッド, 生成されたソースの関数/メソッドを駆使して実処理を書く
    * ROOTパッケージ下に機能追加・拡張で使用する処理を記載した`EXTENSION.go`を各々用意する
        * `init`関数を定義
            * `T.Register`メソッドを実行してextpointを登録する
            * Registerメソッドにはに定義した型の参照(`new(T)`)を渡す
        * 新しい型(structが多い)を定義し、その型にextpointsのT型で定義されているメソッドを実装する
        * 今後追加したいextpointがあれば、同様のgoファイルを追加していく
* generate時に生成するソースのテンプレートとなっている`template.go`で定義されている者達
    * 固定
        * `Register`関数
        * `Unregister`関数
        * `ep`変数 = `extensionPoint`型のstruct
            * `Register`メソッド
            * `Unregister`メソッド
            * `Lookup`メソッド
            * `All`メソッド
    * 動的
        * `TYPEs`変数 - extpointで定義したinterface型の複数形（型は配列）の名前の変数
